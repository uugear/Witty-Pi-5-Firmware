#include "flash.h"
#include "log.h"
#include "led.h"


uint8_t boot_sector[FAT_BLOCK_SIZE] = {
    //---------------- Sector 0: Boot Sector ----------------//
    0xEB, 0x3C, 0x90, // Jump Instruction
    0x4D, 0x53, 0x44, 0x4F, 0x53, 0x35, 0x2E, 0x30, // OEM Name
    0x00, 0x02,  // Bytes per Sector 512=0x0200
    0x08,        // Sectors per Cluster
    0x08, 0x00,  // Reserved Sectors
    0x02,        // Number of FATs
    0x00, 0x02,  // Max Root Directory Entries
    0x00, 0x70,  // Total Sectors (if < 65536) 0x7000=28672
    0xF8,        // Media Descriptor
    0x10, 0x00,  // Sectors per FAT
    0x20, 0x00,  // Sectors per Track
    0x02, 0x00,  // Number of Heads
    0x00, 0x00, 0x00, 0x00, // Hidden Sectors
    0x00, 0x00, 0x00, 0x00, // Total Sectors (if â‰¥ 65536)
                            0x80, 0x00, 0x29, 0x34, 0x12, 0x00, 0x00, 'W' , 'i' , 't' , 't' , 'y' ,
    ' ' , 'P' , 'i' , ' ' , '5' , ' ' , 0x46, 0x41, 0x54, 0x31, 0x32, 0x20, 0x20, 0x20, 0x00, 0x00,
    
    // Zero up to 2 last bytes of FAT magic code
    0xBE, 0x5B, 0x7C, 0xAC, 0x22, 0xC0, 0x74, 0x0B, 0x56, 0xB4, 0x0E, 0xBB, 0x07, 0x00, 0xCD, 0x10,
    0x5E, 0xEB, 0xF0, 0x32, 0xE4, 0xCD, 0x16, 0xCD, 0x19, 0xEB, 0xFE, 0x54, 0x68, 0x69, 0x73, 0x20, 
    0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x20, 0x62, 0x6F, 0x6F, 0x74, 0x61, 0x62, 0x6C, 
    0x65, 0x20, 0x64, 0x69, 0x73, 0x6B, 0x2E, 0x20, 0x20, 0x50, 0x6C, 0x65, 0x61, 0x73, 0x65, 0x20, 
    0x69, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x20, 0x61, 0x20, 0x62, 0x6F, 0x6F, 0x74, 0x61, 0x62, 0x6C, 
    0x65, 0x20, 0x66, 0x6C, 0x6F, 0x70, 0x70, 0x79, 0x20, 0x61, 0x6E, 0x64, 0x0D, 0x0A, 0x70, 0x72, 
    0x65, 0x73, 0x73, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x74, 
    0x72, 0x79, 0x20, 0x61, 0x67, 0x61, 0x69, 0x6E, 0x20, 0x2E, 0x2E, 0x2E, 0x20, 0x0D, 0x0A, 0x00, 
    
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA
};

uint8_t fat_sector[FAT_BLOCK_SIZE] = {
    0xF8, 0xFF, 0xFF
};

uint8_t root_dir_sector[FAT_BLOCK_SIZE] = {
    'W' , 'i' , 't' , 't' , 'y' , ' ' , 'P' , 'i' , ' ' , '5' , ' ' , 0x08, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4F, 0x6D, 0x65, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
};


/**
 * Write 4k sector into flash
 * 
 * @param offset The sector offset
 * @param b0 Pointer to block0
 * @param b1 Pointer to block1
 * @param b2 Pointer to block2
 * @param b3 Pointer to block3
 * @param b4 Pointer to block4
 * @param b5 Pointer to block5
 * @param b6 Pointer to block6
 * @param b7 Pointer to block7
 * @return number of written bytes
 */
int flash_write_4k_sector(int offset, uint8_t *b0, uint8_t *b1, uint8_t *b2, uint8_t *b3, 
                           uint8_t *b4, uint8_t *b5, uint8_t *b6, uint8_t *b7) {
    
    uint8_t zeros[FAT_BLOCK_SIZE] = {};
    
    int index = FLASH_FAT_OFFSET + offset;
    flash_range_erase(index, FLASH_SECTOR_SIZE);
    
    flash_range_program(index, b0 ? b0 : zeros, FAT_BLOCK_SIZE);
    index += FAT_BLOCK_SIZE;
    
    flash_range_program(index, b1 ? b1 : zeros, FAT_BLOCK_SIZE);
    index += FAT_BLOCK_SIZE;
    
    flash_range_program(index, b2 ? b2 : zeros, FAT_BLOCK_SIZE);
    index += FAT_BLOCK_SIZE;
    
    flash_range_program(index, b3 ? b3 : zeros, FAT_BLOCK_SIZE);
    index += FAT_BLOCK_SIZE;
    
    flash_range_program(index, b4 ? b4 : zeros, FAT_BLOCK_SIZE);
    index += FAT_BLOCK_SIZE;
    
    flash_range_program(index, b5 ? b5 : zeros, FAT_BLOCK_SIZE);
    index += FAT_BLOCK_SIZE;
    
    flash_range_program(index, b6 ? b6 : zeros, FAT_BLOCK_SIZE);
    index += FAT_BLOCK_SIZE;
    
    flash_range_program(index, b7 ? b7 : zeros, FAT_BLOCK_SIZE);
        
    return FLASH_SECTOR_SIZE;
}


/**
 * Initialize FatFS for flash
 */
void flash_fatfs_init(void) {
    uint32_t ints = save_and_disable_interrupts();

    int offset = 0;
    
    // Boot sector (sector 0, offset=0) 
    offset += flash_write_4k_sector(offset, boot_sector, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
    
    // 2 FAT tables: 8KB each (sector 8~23, 24~39, offset=4KB)
    offset += flash_write_4k_sector(offset, fat_sector, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
    offset += flash_write_4k_sector(offset, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
    
    offset += flash_write_4k_sector(offset, fat_sector, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
    offset += flash_write_4k_sector(offset, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
    
    // Root directory: 16KB (sector 40~71, offset=20KB)
    offset += flash_write_4k_sector(offset, root_dir_sector, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
    offset += flash_write_4k_sector(offset, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
    offset += flash_write_4k_sector(offset, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
    offset += flash_write_4k_sector(offset, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);    
    
    restore_interrupts(ints);
}


/**
 * Read specific block into buffer
 * 
 * @param block The block offset
 * @param buffer Pointer to buffer
 * @param buffer_size Size of buffer
 * @return true if read succeed
 */
bool flash_fatfs_read(int block, uint8_t *buffer, size_t buffer_size) {
    const uint8_t *data = (uint8_t *)(XIP_BASE + FLASH_FAT_OFFSET + FAT_BLOCK_SIZE * block);
    memcpy(buffer, data, buffer_size);
    return true;
}


/**
 * Write data in buffer to specific block
 * 
 * @param block The block offset
 * @param buffer Pointer to buffer
 * @param buffer_size Size of buffer
 * @return true if write succeed
 */
bool flash_fatfs_write(int block, uint8_t *buffer, size_t buffer_size) {
    
    control_led(true, 0);
    
    // Calculate the start and end flash sector
    uint32_t start_addr = block * FAT_BLOCK_SIZE;
    uint32_t end_addr = start_addr + buffer_size;
    int start_flash_sector = start_addr / FLASH_SECTOR_SIZE;
    int end_flash_sector = (end_addr - 1) / FLASH_SECTOR_SIZE;
    
    // Temporary buffer for storing a whole flash sector
    uint8_t sector_buffer[FLASH_SECTOR_SIZE];
    
    // Temporarily disable USB and interrupts to avoid interference
    stdio_set_driver_enabled(&stdio_usb, false);
    uint32_t ints = save_and_disable_interrupts();
    
    // Process every affected flash sector
    for (int curr_sector = start_flash_sector; curr_sector <= end_flash_sector; curr_sector++) {
        // Read current flash sector
        uint32_t curr_sector_addr = FLASH_FAT_OFFSET + (curr_sector * FLASH_SECTOR_SIZE);
        memcpy(sector_buffer, (uint8_t *)(XIP_BASE + curr_sector_addr), FLASH_SECTOR_SIZE);
        
        // Calculate the range to be updated in current sector
        uint32_t sector_start_offset = (curr_sector == start_flash_sector) ? 
            (start_addr % FLASH_SECTOR_SIZE) : 0;
        uint32_t sector_end_offset = (curr_sector == end_flash_sector) ? 
            (end_addr % FLASH_SECTOR_SIZE) : FLASH_SECTOR_SIZE;
        if (sector_end_offset == 0) sector_end_offset = FLASH_SECTOR_SIZE;
        
        // Calculate the data offset in buffer
        uint32_t buffer_offset = (curr_sector - start_flash_sector) * FLASH_SECTOR_SIZE;
        
        // Update sector buffer acordingly
        uint32_t update_size = sector_end_offset - sector_start_offset;
        memcpy(sector_buffer + sector_start_offset, 
               buffer + buffer_offset, 
               update_size);
        
        //debug_log("Update flash sector %d from %d to %d\n", curr_sector, sector_start_offset, sector_start_offset + update_size);       
        
        
        // Erase and rewrite the whole sector
        flash_range_erase(curr_sector_addr, FLASH_SECTOR_SIZE);
        flash_range_program(curr_sector_addr, sector_buffer, FLASH_SECTOR_SIZE);
    }
        
    // Restore interupts and USB
    restore_interrupts(ints);
    stdio_set_driver_enabled(&stdio_usb, true);
    
    control_led(false, 0);
    
    return true;
}